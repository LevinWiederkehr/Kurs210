<html>
    <header>
        <style>
            body {
                font-family: Arial, sans-serif;
                background-color: #f4f4f4;
                color: #333;
                padding: 20px;
            }
    
            main {
                max-width: 800px;
                margin: auto;
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            }
    
            h1 {
                color: #007acc;
            }
    
            p, li {
                font-size: 16px;
                transition: color 0.3s ease-in-out, background 0.3s ease-in-out;
                cursor: pointer;
            }
    
            p:hover, li:hover {
                color: white;
                background: linear-gradient(90deg, #007acc, #00cc99);
                padding: 5px;
                border-radius: 5px;
            }
        </style>
    </header>
    <body>
        <main>
            <div>
                <h1>Cloud-Computing | Was wissen wir</h1>
                <p>Server, Speicher, Datenbanken, Netzwerk, Software</p>
                <p>Cloud-Anbieter: AWS, Azure, ...</p>
                <p>Webserver, Datenbankserver</p>
                <p>on Premise</p>
                <p>Native Cloud</p>
                <p>Hybrid Cloud</p>
                <p>IaaS, SaaS, PaaS,</p>
                <p>Firewall</p>
                <p>Cloud-init, YAML</p>
                <p>Vertikale und horizontale Skalierung</p>
                <p>VPC, Subnetze</p>
                <p>Oeffentliche, Private, elastische und Statische IP-Adressen</p>
                <p>Auto-Scaling, Load Balancer</p>
            </div>
            <div>
                <h1>Grundlagen</h1>
                <p>Wolke als Symbol für Netzwerke</p>
                <p>On-Demand-Netzwerkzugriff auf gemeinsam genutzte Ressourcen</p>
                <p>5 Merkmale einer Cloud (NIST)</p>
                <ul>
                    <li>On-Demand Self-Service – Automatische Bereitstellung</li>
                    <li>Breiter Netzwerkkapazitätszugang – Zugriff über Internet</li>
                    <li>Ressourcen-Pooling – Gemeinsame Nutzung von Ressourcen</li>
                    <li>Schnelle Elastizität – Skalierbarkeit nach Bedarf</li>
                    <li>Messbarer Service – Nutzung wird überwacht und abgerechnet</li>
                </ul>
                <p>Cloud-Dienstleistungen</p>
                <ul>
                    <li>Speicher (z. B. Google Drive, Dropbox)</li>
                    <li>Rechenleistung (z. B. AWS EC2, Azure VMs)</li>
                    <li>Datenbanken (z. B. AWS RDS)</li>
                    <li>KI-Dienste (z. B. OpenAI, Google AI)</li>
                </ul>
                <p>Cloud-Anbieter</p>
                <ul>
                    <li>Hyperscaler: AWS, Microsoft Azure</li>
                    <li>Weitere: IBM Cloud, Oracle Cloud, Alibaba Cloud</li>
                </ul>
                <p>Cloud-Deployment-Modelle</p>
                <ul>
                    <li>Public Cloud – Öffentliche Cloud (AWS, Azure)</li>
                    <li>Private Cloud – Interne Cloud eines Unternehmens</li>
                    <li>Hybrid Cloud – Kombination aus Public und Private Cloud</li>
                    <li>Community Cloud – Geteilte Cloud für eine Gruppe von Organisationen</li>
                </ul>
                <p>Cloud-Service-Modelle</p>
                <ul>
                    <li>IaaS (Infrastructure as a Service) – Virtuelle Maschinen, Netzwerke</li>
                    <li>PaaS (Platform as a Service) – Entwicklungsplattformen</li>
                    <li>SaaS (Software as a Service) – Webanwendungen (z. B. Gmail, Office 365)</li>
                </ul>
                <p>Vorteile von Cloud-Diensten</p>
                <ul>
                    <li>Skalierbarkeit</li>
                    <li>Kostenreduktion</li>
                    <li>Hohe Verfügbarkeit</li>
                    <li>Automatische Updates</li>
                    <li>Ortsunabhängiger Zugriff</li>
                </ul>
                <p>Nachteile von Cloud-Diensten</p>
                <ul>
                    <li>Abhängigkeit vom Anbieter</li>
                    <li>Datenschutzrisiken</li>
                    <li>Internetabhängigkeit</li>
                    <li>Mögliche versteckte Kosten</li>
                </ul>
                <p>On-Premise-Dienste (Eigenes Rechenzentrum)</p>
                <p>NICHTS</p>
                <p>Bereitstellung technologischer Beiträge in der Cloud</p>
                <ul>
                    <li>APIs</li>
                    <li>Open-Source-Plattformen</li>
                    <li>Cloud-Marktplätze</li>
                    <li>Container (z. B. Docker, Kubernetes)</li>
                </ul>
            </div>
            <div>
                <h1>Container-Technologie</h1>
                <p><b>Was ist Container-Technologie oder Container-Virtualisierung?</b></p>
                <p>Container-Technologie ermöglicht die Isolation und Ausführung von Anwendungen in leichtgewichtigen, portablen Umgebungen, die alle erforderlichen Abhängigkeiten enthalten.</p>
                
                <p><b>Vor- und Nachteile der Container-Technologie zu virtuellen Servern (VM)</b></p>
                <ul>
                    <li>Vorteile: Geringerer Speicherverbrauch, schnellere Bereitstellung, bessere Portabilität</li>
                    <li>Nachteile: Weniger Isolation als VMs, Abhängigkeit vom Host-Betriebssystem</li>
                </ul>
                
                <p><b>Bekannte Produkte im Bereich virtueller Server und Container</b></p>
                <ul>
                    <li>Virtuelle Server: VMware, VirtualBox, Hyper-V</li>
                    <li>Container: Docker, Kubernetes, OpenShift</li>
                </ul>
                
                <p><b>Unterschiede zwischen VM und Container</b></p>
                <ul>
                    <li>Bereitstellung: Container sind schneller startklar</li>
                    <li>Speicherplatz: Container benötigen weniger Ressourcen</li>
                    <li>Portabilität: Container sind flexibler über verschiedene Umgebungen hinweg</li>
                    <li>Effizienz: Container teilen sich das Host-Betriebssystem, VMs benötigen ein vollständiges OS</li>
                    <li>Betriebssystem: Container nutzen den Host-Kernel, VMs haben ihr eigenes Kernel</li>
                </ul>
                
                <p><b>Können virtuelle Server immer durch Container ersetzt werden?</b></p>
                <p>Nein, Container sind nicht für alle Anwendungen geeignet, insbesondere wenn eine vollständige Isolation oder unterschiedliche Betriebssysteme erforderlich sind.</p>
                
                <p><b>Unterschied zwischen Self-Managed und Fully Managed</b></p>
                <ul>
                    <li>Self-Managed: Benutzer ist für die Wartung und Konfiguration verantwortlich</li>
                    <li>Fully Managed: Anbieter übernimmt Wartung, Updates und Monitoring</li>
                </ul>
            </div>
            <div>
                <h1>Docker Image starten mit dockerfile</h1>
                <p>0.1 Nginx pullen</p>
                <p>docker pull nginx</p>
                <p>0.2 Welche images hat man?</p>
                <p>docker image ls</p>
                <p>1. Dockerfile erstellen</p>
                <p> FROM nginx:latest
                    COPY ./html /usr/share/nginx/html
                    EXPOSE 80
                </p>
                <p>2. Docker-Image bauen</p>
                <p>docker build -t namevomimage .</p>
                <p>3. Container starten</p>
                <p>docker run --name namevomcontainer -p 8080:80 -d namevomimage</p>
                <p>Mit docker-compose-file:</p>
                <pre>
            version: '3'
            services:
              web:
                image: nginx:latest            # Verwende das offizielle Nginx-Image
                container_name: namevomcontainer
                ports:
                  - "8080:80"                  # Mappt den Host-Port 8080 auf den Container-Port 80
                volumes:
                  - ./html:/usr/share/nginx/html   # Bindet das Verzeichnis 'html' im Container ein
                </pre>
                <p>Docker Compose starten</p>
                <p>docker-compose up -d</p>
            </div>
            <div>
                <h1>Container-Orchestrierung</h1>
                <p><strong>Warum braucht man Container-Orchestrierung?</strong></p>
                <ul>
                    <li>Automatisierung der Bereitstellung, Verwaltung und Skalierung von Containern</li>
                    <li>Effiziente Nutzung von Ressourcen</li>
                    <li>Fehlertoleranz und Selbstheilung von Anwendungen</li>
                    <li>Optimierung der Netzwerkkommunikation zwischen Containern</li>
                </ul>
                
                <p><strong>Wie funktioniert Container-Orchestrierung?</strong></p>
                <ul>
                    <li>Verwaltung und Planung von Containern auf mehreren Hosts</li>
                    <li>Automatische Skalierung basierend auf der Last</li>
                    <li>Load Balancing und Service Discovery</li>
                    <li>Monitoring und Logging für Container</li>
                </ul>
                
                <p><strong>Welche Container-Orchestrierung Technologien kennen Sie?</strong></p>
                <ul>
                    <li>Kubernetes</li>
                    <li>Docker Swarm</li>
                    <li>Amazon ECS (Elastic Container Service)</li>
                    <li>Nomad</li>
                    <li>Apache Mesos</li>
                </ul>
                
                <p><strong>Was versteht man unter "Scaling Containers"?</strong></p>
                <ul>
                    <li>Erhöhen oder Verringern der Anzahl laufender Container basierend auf der Last</li>
                    <li>Horizontale Skalierung: Hinzufügen oder Entfernen von Container-Instanzen</li>
                    <li>Vertikale Skalierung: Zuweisung zusätzlicher Ressourcen zu bestehenden Containern</li>
                    <li>Automatische Skalierung durch Orchestrierungs-Tools</li>
                </ul>
                
                <p><strong>Was gibt es für Deployment Strategien?</strong></p>
                <ul>
                    <li>Recreate: Alle alten Container werden gestoppt und neue gestartet</li>
                    <li>Rolling Update: Schrittweises Ersetzen alter Container durch neue</li>
                    <li>Blue-Green Deployment: Zwei Umgebungen (alt und neu), Umschalten zwischen ihnen</li>
                    <li>Canary Deployment: Neue Version wird schrittweise an eine kleine Benutzergruppe ausgerollt</li>
                    <li>A/B Testing: Vergleich verschiedener Versionen für unterschiedliche Benutzergruppen</li>
                </ul>
            </div>
            <div>
                <h1>Weitere Themen</h1>
                <p><strong>Was ist Redis?</strong></p>
                <ul>
                    <li>In-Memory-Datenbank mit hoher Geschwindigkeit</li>
                    <li>Unterstützt verschiedene Datenstrukturen (Strings, Hashes, Listen, Sets)</li>
                    <li>Wird für Caching, Sitzungsverwaltung und Echtzeitanalysen genutzt</li>
                </ul>
                
                <p><strong>Welche Ports werden genutzt?</strong></p>
                <ul>
                    <li>Standardport für Redis: 6379</li>
                    <li>Für verschlüsselte Verbindungen: 6380</li>
                    <li>Andere Ports je nach Konfiguration und Sicherheitsanforderungen</li>
                </ul>
                
                <p><strong>Was ist die Bedeutung von ENV im DOCKERFILE?</strong></p>
                <ul>
                    <li>Definiert Umgebungsvariablen für Container</li>
                    <li>Ermöglicht Konfigurationsanpassungen ohne Änderung des Images</li>
                    <li>Wird zur Steuerung von Laufzeiteinstellungen genutzt</li>
                </ul>
            </div>
        </main>
    </body>
</html>